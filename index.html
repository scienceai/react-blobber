<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv='Content-type' content='text/html; charset=utf-8'>
    <title>Basic Example with JSX and ES6 features</title>
    <link rel="stylesheet" href="blobber.css" />
  </head>
  <body>
    <h1>Blobber</h1>
    <div id="container">
      <p>
        To install React, follow the instructions on
        <a href="https://github.com/facebook/react/">GitHub</a>.
      </p>
      <p>
        If you can see this, React is not working right.
        If you checked out the source from GitHub make sure to run <code>grunt</code>.
      </p>
    </div>
    <h4>Example Details</h4>
    <p>This is written with JSX with Harmony (ES6) syntax and transformed in the browser.<p>
    <p>
      Learn more about React at
      <a href="https://facebook.github.io/react" target="_blank">facebook.github.io/react</a>.
    </p>
    <script src="react.js"></script>
    <script src="JSXTransformer.js"></script>
    <script src="convex_hull.js"></script>
    <script type="text/jsx;harmony=true">


      class ExampleApplication extends React.Component {

        orthoConvexHull(rects, offset){

        //Orthogonal/X-Y Convex Hull


        // roughly based on python code found at:
        // http://stackoverflow.com/questions/14409743/dynamic-and-or-static-rectilinear-orthogonal-x-y-convex-hull

          var points = [];

          // get all the points in the rect Array
          for(var i = 0; i < rects.length; i++){
            points.push({x: rects[i].x1 - offset, y: rects[i].y1 - offset});
            points.push({x: rects[i].x1 - offset, y: rects[i].y2 + offset});
            points.push({x: rects[i].x2 + offset, y: rects[i].y2 + offset});
            points.push({x: rects[i].x2 + offset, y: rects[i].y1 - offset});
            // points.push({x: rects[i].x1, y: rects[i].y1});
            // points.push({x: rects[i].x1, y: rects[i].y2});
            // points.push({x: rects[i].x2, y: rects[i].y2});
            // points.push({x: rects[i].x2, y: rects[i].y1});
          }

          console.log('points: ', JSON.stringify(points));

          // find min and max values of y
          var min_y = Number.POSITIVE_INFINITY;
          var min_yPoint;
          var max_y = Number.NEGATIVE_INFINITY;
          var max_yPoint;
          var min_x = Number.POSITIVE_INFINITY;
          var min_xPoint;
          var max_x = Number.NEGATIVE_INFINITY;
          var max_xPoint;
          var tmp;
          for(i = points.length-1; i>=0; i--){
            tmp = points[i].y;
            if(tmp < min_y){
              min_yPoint = points[i];
              min_y = points[i].y;
            } else if(tmp > max_y) {
              max_yPoint = points[i];
              max_y = points[i].y;
            }
            tmp = points[i].x;
            if(tmp < min_x){
              min_xPoint = points[i];
              min_x = points[i].x;
            } else if(tmp > max_x) {
              max_xPoint = points[i];
              max_x = points[i].x;
            }
          }
          //debugger;
          // sort points by x coordinate, then by y
          points.sort(function(a,b){
              // if(a.y == b.y) return a.x-b.x;
              // return a.y-b.y;
              if(a.x == b.x) return a.y-b.y;
              return a.x-b.x;

          });

          console.log('sorted points: ', JSON.stringify(points));

          console.log('minYPoint: ', min_yPoint);
          console.log('maxYPoint: ', max_yPoint);

          // duplicate array
          var reversedPoints = points.slice(0);
          // and reverse
          reversedPoints.reverse();

          // construct upper paths
          var upperLeft = this.orthoBuildUpperLeft(points, min_yPoint);
          console.log('upperLeft: ', upperLeft );
          var upperRight = this.orthoBuildUpperRight(reversedPoints, max_xPoint);
          console.log('upperRight: ', upperRight );

          // construct lower paths
          var lowerLeft = this.orthoBuildLowerLeft(points, max_yPoint);
          console.log('lowerLeft: ', lowerLeft);
          var lowerRight = this.orthoBuildLowerRight(reversedPoints, max_yPoint);
          console.log('lowerRight: ', lowerRight);

          upperRight.reverse();
          lowerRight.reverse();
          lowerLeft.reverse();


          var hull = upperLeft.concat(upperRight, lowerRight, lowerLeft);
          //var hull = lowerRight;
          //var hull = lowerLeft.concat(lowerRight, upperLeft, upperRight);
          console.log('hull', JSON.stringify(hull));

          // remove repeats
          // for(i = 1; i < hull.length; i++){
          //   if(hull[i].x == hull[i-1].x && hull[i].y == hull[i-1].y){
          //     // remove duplicate
          //     hull.splice(i, 1);
          //     i--;
          //   }
          // }
          //      console.log('cleaned hull', JSON.stringify(hull));

        //  remove all duplicate points
        hull = hull.reduce((prev, curr) => {
           if (!prev.some(point => point.x === curr.x && point.y === curr.y)) {
             prev.push(curr);
           }
            return prev;
         }, []);

        // remove redundant points on lines
        for(i=2; i<hull.length; i++){
          if(hull[i-2].x == hull[i-1].x && hull[i-1].x == hull[i].x){
            console.log('remove: ', hull[i-2].x, hull[i-1].x, hull[i].x );
            hull.splice(i-1, 1);
          }
        }
        for(i=2; i<hull.length; i++){
          if(hull[i-2].y == hull[i-1].y && hull[i-1].y == hull[i].y){
            console.log('remove: ', hull[i-2].y, hull[i-1].y, hull[i].y );
            hull.splice(i-1, 1);

          }
        }
        // var closeLine = [{x: hull[hull.length-1].x, y: hull[hull.length-1].y},
        //                  {x: hull[0].x, y: hull[0].y}];

           hull = hull.concat([{x: hull[0].x, y: hull[0].y}]);
           //console.log('closeLine: ', JSON.stringify(closeLine));

           console.log('cleaned hull', JSON.stringify(hull));

          //  hull = upperLeft;
          // hull = upperRight;
          //
          // hull = lowerRight;

          // hull = lowerLeft;


          return(hull);
        }


      orthoBuildLowerLeft(points){
        var section = [points[0]];

        for(var i=0; i < points.length; i++){
          console.log('x,y: ', points[i].x, points[i].y);
          if(section.length > 1){
            if(points[i].y == section[section.length-1].y){
              // horizontal line
              if(points[i].x >section[section.length-1].x){
                //right
                section.push(points[i]);
              }
            }
            if(points[i].x == section[section.length-1].x){
              // vertical line
              if(points[i].y > section[section.length-1].y){
                section.push(points[i]);
              }
            }
            if(points[i].y > section[section.length-1].y){
              if(points[i].x > section[section.length-1].x){
                // down right
                //section[section.length-1].y = points[i].y
                var y = section[section.length-1].y;
                var x = points[i].x
                section.push({x: x, y: y});
                section.push(points[i]);
              }
            }
          } else {
            // first point
            section.push(points[i]);
          }
        }
        return section;
      }
      orthoBuildLowerRight(points, max_yPoint){
        var section = [max_yPoint];

        for(var i=0; i < points.length; i++){
          console.log('lr x,y: ', points[i].x, points[i].y);
          if(section.length >= 1){
            if(points[i].y == section[section.length-1].y){
              // horizontal line
              if(points[i].x > section[section.length-1].x){
                //right
                section.push(points[i]);
              }
            }
            if(points[i].x == section[section.length-1].x){
              // vertical line
              if(points[i].y < section[section.length-1].y){
                section.push(points[i]);
              }
            }
            if(points[i].y < section[section.length-1].y){
              if(points[i].x > section[section.length-1].x){
                // up right
                //section[section.length-1].x = points[i].x
                var x = section[section.length-1].x;
                var y = points[i].y
                section.push({x: x, y: y});
                section.push(points[i]);
              }
            }
          } else {
            // first point
            // if(points[i].y == max_yPoint){
            //   section.push(points[i]);
            // }
          }
        }
        return section;
      }
      orthoBuildUpperLeft(points, min_yPoint){
        var section = [points[0]];

        for(var i=0; i < points.length; i++){
          console.log('x,y: ', points[i].x, points[i].y);
          if(section.length > 1){
            if(points[i].y == section[section.length-1].y){
              // horizontal line
              if(points[i].x > section[section.length-1].x){
                //right
                section.push(points[i]);
              }
            }
            if(points[i].x == section[section.length-1].x){
              // vertical line
              if(points[i].y < section[section.length-1].y){
                section.push(points[i]);
              }
            }
            if(points[i].y < section[section.length-1].y){
              if(points[i].x > section[section.length-1].x){
                // up right
                //section[section.length-1].x = points[i].x
                var y = section[section.length-1].y;
                var x = points[i].x
                section.push({x: x, y: y});
                section.push(points[i]);
              }
            }
          } else {
            // first point
            section.push(points[i]);
          }
        }
        return section;
      }

      orthoBuildUpperRight(points, max_xPoint){
        var section = [];
        console.log('buildUpperRight');
        for(var i=0; i < points.length; i++){
          if(section.length > 1){
            if(points[i].y == section[section.length-1].y){
              // horizontal line
              if(points[i].x < section[section.length-1].x){
                section.push(points[i]);
              }
            }
            if(points[i].x == section[section.length-1].x){
              // vertical line
              if(points[i].y < section[section.length-1].y){
                section.push(points[i]);
              }
            }
            if(points[i].y < section[section.length-1].y){
              if(points[i].x < section[section.length-1].x){
                // up left
                //section[section.length-1].x = points[i].x
                var y = section[section.length-1].y;
                var x = points[i].x
                section.push({x: x, y: y});
                section.push(points[i]);
              }
            }
          } else {
            // first point
            if(points[i].x == max_xPoint.x){
              section.push(points[i]);
            }
          }
        }
        return section;
      }

     roundedSVGPath( points, r ){

        var svgPath;

        if (!points.length) return;

        //compute the middle of the first line as start-stop-point:
       var deltaX, deltaY, xPerY, startX, startY;

        svgPath = 'M';

        for (var i = 1; i < points.length; i++){

          var deltaX2, deltaY2;

          // some logic to deel with closing the loop
          if(i < points.length-1){
            deltaX = points[i].x - points[i-1].x;
            deltaY = points[i].y - points[i-1].y;
            deltaX2 = points[i+1].x - points[i].x;
            deltaY2 = points[i+1].y - points[i].y;

          } else if (i == points.length-1){
            deltaX = points[i].x - points[i-1].x;
            deltaY = points[i].y - points[i-1].y;
            deltaX2 = points[1].x - points[i].x;
            deltaY2 = points[1].y - points[i].y
          }

          console.log('delta x y: ', i,  deltaX, deltaY);
          console.log('delta2 x y: ', i,  deltaX2, deltaY2);
          var rX = 100;
          var rY = 100;
          console.log('r:', r);
          if(r < Math.ceil(Math.abs(deltaX)/2)){
            console.log('rd:', deltaX);
             rX = r;
          } else if (deltaX != 0) {
            rX = Math.ceil(Math.abs(deltaX)-1/2);
          }
          if(r < Math.ceil(Math.abs(deltaY)-1/2)){
            rY = r;
          } else if (deltaY != 0) {
            rY = Math.ceil(Math.abs(deltaY)/2);
          }
          // var rX = r > Math.abs(deltaX) ? Math.abs(deltaX) : r;
          // var rY = r > Math.abs(deltaY) ? Math.abs(deltaY) : r;
          console.log('r', r, rX, rY);
          var radius = rX < rY ? rX : rY;
          var negRadius = -1 * radius;

          console.log('radius: ', radius);
          //svgPath += ' L ' + (points[i].x ) + ' ' + (points[i].y );

          if(deltaY < 0){
            // up
            if (svgPath == 'M') svgPath += ' ' + points[0].x + ' ' + (points[0].y - radius);
            svgPath += ' l ' + (deltaX) + ' ' + (deltaY + (radius * 2));

            if(deltaX2 < 0){
              // up then left

              svgPath += ' s 0 ' + negRadius + ' ' + negRadius + ' ' + negRadius;
            } else if (deltaX2 > 0){
              // up then right
              svgPath += ' s 0 ' + negRadius + ' ' + radius + ' ' + negRadius;
            }
          } else if(deltaY > 0){
            //down
            if (svgPath == 'M') svgPath += ' ' + points[0].x + ' ' + (points[0].y + radius);

            svgPath += ' l ' + (deltaX) + ' ' + (deltaY - (radius*2) );
            if(deltaX2 < 0){
              // down then left
              svgPath += ' s 0 ' + radius + ' ' + negRadius + ' ' + radius;
            } else if (deltaX2 > 0){
              // down then right
              svgPath += ' s 0 ' + ' ' + radius + ' ' + radius + ' ' + radius;
            }
          } else if (deltaX < 0){
            // left
            if (svgPath == 'M') svgPath += ' ' + (points[0].x - radius) + ' ' + (points[0].y);
            svgPath += ' l ' + (deltaX + (radius*2)) + ' ' + (deltaY);

            if(deltaY2 < 0){
              // left, then up
              svgPath += ' s ' + negRadius + ' 0 ' + negRadius + ' ' + negRadius;
            }
            if(deltaY2 > 0){
              // left, then down
              svgPath += ' s ' + negRadius + ' 0 ' + negRadius + ' '+  radius;
            }
          } else if (deltaX > 0){
              // right
              if (svgPath == 'M') svgPath += ' ' + (points[0].x + radius) + ' ' + (points[0].y);

              svgPath += ' l ' + (deltaX + (radius*-2)) + ' ' + (deltaY);
              if(deltaY2 > 0){
                // right, then down
                svgPath += ' s ' + radius + ' 0 ' + radius + ' ' + radius;
              }
              if(deltaY2 < 0){
                // right, then up
                svgPath += ' s ' + ' ' + radius + ' 0 ' + radius + ' ' + negRadius;
              }
          }

        }

        // close the shape

        console.log('svgPath: ', svgPath);
        return svgPath;
    }


        render() {

          console.log('rects1');
          var rects = [{x1:30, y1:60, x2:180, y2:120},{x1:60, y1:30, x2:155, y2:100}, {x1:115, y1:15, x2:275, y2:50}];
          var hull = this.orthoConvexHull(rects, 10);
          //hull.reverse();
          var roundedHullStr = this.roundedSVGPath(hull, 12);
          console.log('hull', hull);

          var svgPointsStr = '';
          for(var i=0; i<hull.length; i++){
            console.log('point: ', hull[i].x);
            svgPointsStr = svgPointsStr + hull[i].x + ',' + hull[i].y + ' ';
          }

          var svgRects = rects.map(function(rect, id){
            return(
                <rect fill="grey" x={rect.x1} y={rect.y1} width={rect.x2-rect.x1} height={rect.y2-rect.y1} key={'svgrect_' + id}/>
            )

          });

          console.log('rects2');
          var rects2 = [{x1:30, y1:60, x2:60, y2:120}, {x1:105, y1:20, x2:175, y2:150}];
          var hull2 = this.orthoConvexHull(rects2, 16);
          //hull.reverse();
          var roundedHullStr2 = this.roundedSVGPath(hull2, 16);
          console.log('hull2', hull2);

          var svgPointsStr2 = '';
          for(var i=0; i<hull2.length; i++){
            console.log('point: ', hull2[i].x);
            svgPointsStr2 = svgPointsStr2 + hull2[i].x + ',' + hull2[i].y + ' ';
          }

          var svgRects2 = rects2.map(function(rect, id){
            return(
                <rect fill="grey" x={rect.x1} y={rect.y1} width={rect.x2-rect.x1} height={rect.y2-rect.y1} key={'svgrect_' + id}/>
            )

          });
          // <path fill="green" opacity=".125" stroke="green" d={roundedHullStr}/>
          // <path fill="orange" opacity=".125" stroke="green" d={roundedHullStr2}/>
            return(
              <div className='svgContainer'>
                <div className='container'>
                  <svg width='400' height='400'>
                    {svgRects}
                    <polyline fill="none" opacity=".25" stroke="blue" points={svgPointsStr}/>
                    <path fill="purple" opacity=".5" stroke="black" d={roundedHullStr}/>
                  </svg>
                </div>
                <div className='container'>
                  <svg width='400' height='400'>
                    {svgRects2}
                    <polyline fill="none" stroke="red" points={svgPointsStr2}/>
                    <path fill="orange" opacity=".25" stroke="green" d={roundedHullStr2}/>
                  </svg>
                </div>
              </div>
            );
          // var elapsed = Math.round(this.props.elapsed  / radius0);
          // var seconds = elapsed / radius + (elapsed % radius ? '' : '.0' );
          // var message =
          //   `React has been successfully running for ${seconds} seconds.`;
          //
          // return <p>{message}</p>;
        }
      }

      React.render(
          <ExampleApplication elapsed={new Date().getTime() - start} />,
          document.getElementById('container')
      );

      var start = new Date().getTime();
      // setInterval(() => {
      //   React.render(
      //     <ExampleApplication elapsed={new Date().getTime() - start} />,
      //     document.getElementById('container')
      //   );
      // }, 50);
    </script>
  </body>
</html>
